// main/mlkem_server.c
#include <string.h>
#include <sys/param.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <errno.h>
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "esp_event.h"
#include "esp_log.h"
#include "esp_netif.h"
#include "esp_system.h"
#include "esp_wifi.h"
#include "nvs_flash.h"

// Pulls in crypto_kem_* prototypes via your component
#include "kem.h"      // provided by your mlkem component (include/src on your CMake)

static const char *TAG = "MLKEM-SRV";

// --- ML-KEM-768 sizes (constant in the spec) ---
#define MLKEM_PK_BYTES  1184
#define MLKEM_SK_BYTES  2400
#define MLKEM_CT_BYTES  1088
#define MLKEM_SS_BYTES  32

// --- SoftAP defaults (change if you like) ---
#define AP_SSID     "mlkem-ap"
#define AP_PASS     "mlkempass"   // >= 8 chars
#define AP_CHANNEL  6
#define AP_MAX_CONN 1

#define SRV_PORT    8081
#define RECV_TIMEOUT_MS 10000

static uint8_t g_pk[MLKEM_PK_BYTES];
static uint8_t g_sk[MLKEM_SK_BYTES];

static void hex32(const uint8_t *in, char out_hex[MLKEM_SS_BYTES * 2 + 1]) {
    static const char *hexd = "0123456789abcdef";
    for (int i = 0; i < MLKEM_SS_BYTES; ++i) {
        out_hex[2*i]   = hexd[(in[i] >> 4) & 0xF];
        out_hex[2*i+1] = hexd[in[i] & 0xF];
    }
    out_hex[MLKEM_SS_BYTES * 2] = '\0';
}

static esp_err_t wifi_init_softap(void) {
    ESP_ERROR_CHECK(esp_netif_init());
    ESP_ERROR_CHECK(esp_event_loop_create_default());
    esp_netif_create_default_wifi_ap();

    wifi_init_config_t cfg = WIFI_INIT_CONFIG_DEFAULT();
    ESP_ERROR_CHECK(esp_wifi_init(&cfg));

    wifi_config_t ap_cfg = {
        .ap = {
            .ssid = AP_SSID,
            .ssid_len = 0,
            .channel = AP_CHANNEL,
            .password = AP_PASS,
            .max_connection = AP_MAX_CONN,
            .authmode = WIFI_AUTH_WPA_WPA2_PSK,
            .pmf_cfg = {
                .required = false,
            },
        }
    };
    if (strlen(AP_PASS) == 0) {
        ap_cfg.ap.authmode = WIFI_AUTH_OPEN;
    }

    ESP_ERROR_CHECK(esp_wifi_set_mode(WIFI_MODE_AP));
    ESP_ERROR_CHECK(esp_wifi_set_config(WIFI_IF_AP, &ap_cfg));
    ESP_ERROR_CHECK(esp_wifi_start());

    ESP_LOGI(TAG, "SoftAP started: SSID='%s' password='%s' channel=%d",
             AP_SSID, (strlen(AP_PASS) ? AP_PASS : "<open>"), AP_CHANNEL);
    return ESP_OK;
}

static int srv_recv_all(int fd, void *buf, size_t want, int timeout_ms) {
    uint8_t *p = (uint8_t*)buf;
    size_t have = 0;
    struct timeval tv = {
        .tv_sec = timeout_ms / 1000,
        .tv_usec = (timeout_ms % 1000) * 1000
    };
    setsockopt(fd, SOL_SOCKET, SO_RCVTIMEO, &tv, sizeof(tv));

    while (have < want) {
        ssize_t r = recv(fd, p + have, want - have, 0);
        if (r == 0) return 0;              // peer closed
        if (r < 0) {
            if (errno == EAGAIN || errno == EWOULDBLOCK) return -2; // timeout
            return -1; // other error
        }
        have += (size_t)r;
    }
    return (int)have;
}

static void mlkem_server_task(void *arg) {
    (void)arg;

    // Generate server keypair once
    if (crypto_kem_keypair(g_pk, g_sk) != 0) {
        ESP_LOGE(TAG, "crypto_kem_keypair failed");
        vTaskDelete(NULL);
        return;
    }
    ESP_LOGI(TAG, "ML-KEM-768 keypair ready (pk=%dB, sk=%dB)", MLKEM_PK_BYTES, MLKEM_SK_BYTES);

    // Socket setup
    int listen_fd = socket(AF_INET, SOCK_STREAM, IPPROTO_IP);
    if (listen_fd < 0) {
        ESP_LOGE(TAG, "socket() failed: %d", errno);
        vTaskDelete(NULL);
        return;
    }
    int yes = 1;
    setsockopt(listen_fd, SOL_SOCKET, SO_REUSEADDR, &yes, sizeof(yes));

    struct sockaddr_in addr = {
        .sin_family = AF_INET,
        .sin_port = htons(SRV_PORT),
        .sin_addr.s_addr = htonl(INADDR_ANY),
    };
    if (bind(listen_fd, (struct sockaddr*)&addr, sizeof(addr)) < 0) {
        ESP_LOGE(TAG, "bind() failed: %d", errno);
        close(listen_fd);
        vTaskDelete(NULL);
        return;
    }
    if (listen(listen_fd, 1) < 0) {
        ESP_LOGE(TAG, "listen() failed: %d", errno);
        close(listen_fd);
        vTaskDelete(NULL);
        return;
    }
    ESP_LOGI(TAG, "Listening on TCP port %d", SRV_PORT);

    while (true) {
        struct sockaddr_in cli;
        socklen_t slen = sizeof(cli);
        int fd = accept(listen_fd, (struct sockaddr*)&cli, &slen);
        if (fd < 0) {
            ESP_LOGW(TAG, "accept() error: %d", errno);
            continue;
        }
        ESP_LOGI(TAG, "Client connected");

        // Protocol:
        // 1) Server sends: 2-byte big-endian pk_len, then pk bytes
        uint16_t pk_len_be = htons(MLKEM_PK_BYTES);
        if (send(fd, &pk_len_be, 2, 0) != 2 ||
            send(fd, g_pk, MLKEM_PK_BYTES, 0) != MLKEM_PK_BYTES) {
            ESP_LOGW(TAG, "send(pk) failed");
            close(fd);
            continue;
        }

        // 2) Client sends: exactly MLKEM_CT_BYTES ciphertext bytes
        uint8_t ct[MLKEM_CT_BYTES];
        int rr = srv_recv_all(fd, ct, MLKEM_CT_BYTES, RECV_TIMEOUT_MS);
        if (rr <= 0) {
            ESP_LOGW(TAG, "recv(ct) failed: %d", rr);
            close(fd);
            continue;
        }

        // 3) Server decapsulates, replies with "OK " + hex(shared_secret) + "\n"
        uint8_t ss[MLKEM_SS_BYTES];
        int rc = crypto_kem_dec(ss, ct, g_sk);
        if (rc != 0) {
            const char *err = "ERR decap\n";
            send(fd, err, strlen(err), 0);
            ESP_LOGW(TAG, "Decapsulation failed (rc=%d)", rc);
            close(fd);
            continue;
        }

        char ss_hex[MLKEM_SS_BYTES * 2 + 1];
        hex32(ss, ss_hex);
        char line[8 + sizeof(ss_hex)];
        int n = snprintf(line, sizeof(line), "OK %s\n", ss_hex);
        send(fd, line, n, 0);
        ESP_LOGI(TAG, "Shared secret: %s", ss_hex);

        close(fd);
        ESP_LOGI(TAG, "Client disconnected");
    }
}

void app_main(void) {
    // NVS is required by Wi-Fi
    ESP_ERROR_CHECK(nvs_flash_init());
    // (Handle NVS page full/old version cases gracefully)
    if (nvs_flash_init() == ESP_ERR_NVS_NO_FREE_PAGES ||
        nvs_flash_init() == ESP_ERR_NVS_NEW_VERSION_FOUND) {
        ESP_ERROR_CHECK(nvs_flash_erase());
        ESP_ERROR_CHECK(nvs_flash_init());
    }

    ESP_ERROR_CHECK(wifi_init_softap());

    // Server task (8 KB stack is enough here)
    xTaskCreatePinnedToCore(mlkem_server_task, "mlkem_srv", 8192, NULL, 5, NULL, 0);
}
